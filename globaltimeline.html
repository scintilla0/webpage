<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Global Availability Timeline</title>
	<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%233498db'><path d='M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.4 0-8-3.6-8-8s3.6-8 8-8 8 3.6 8 8-3.6 8-8 8z'/><path d='M12 6v6l4 2'/></svg>" type="image/svg+xml">
	<style>
		* {
			box-sizing: border-box;
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
		}

		body {
			max-width: 1200px;
			margin: 0 auto;
			padding: 20px;
			background-color: #f5f7fa;
			color: #333;
		}

		h1 {
			text-align: center;
			color: #2c3e50;
			margin-bottom: 30px;
		}

		.container {
			display: flex;
			flex-wrap: wrap;
			gap: 20px;
		}

		.input-section {
			flex: 1;
			min-width: 300px;
			background: white;
			padding: 20px;
			border-radius: 10px;
			box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
			position: relative;
		}

		.timeline-section {
			flex: 2;
			min-width: 500px;
			background: white;
			padding: 20px;
			border-radius: 10px;
			box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
			display: flex;
			flex-direction: column;
		}

		.form-group {
			margin-bottom: 15px;
		}

		label {
			display: block;
			margin-bottom: 5px;
			font-weight: 600;
			color: #2c3e50;
		}

		input, select, button, textarea {
			width: 100%;
			padding: 10px;
			border: 1px solid #ddd;
			border-radius: 5px;
			font-size: 16px;
		}

		button {
			background-color: #3498db;
			color: white;
			border: none;
			cursor: pointer;
			transition: background-color 0.3s;
			font-weight: 600;
		}

		button:hover {
			background-color: #2980b9;
		}

		.data-actions {
			display: flex;
			gap: 10px;
			margin-top: 20px;
		}

		.data-actions button {
			flex: 1;
		}

		.share-btn {
			background-color: #2ecc71;
		}

		.share-btn:hover {
			background-color: #27ae60;
		}

		.toast-notification {
			position: fixed;
			background: #3498db;
			color: white;
			padding: 12px 20px;
			border-radius: 8px;
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
			z-index: 1000;
			font-weight: 600;
			font-size: 14px;
			pointer-events: none;
			opacity: 0;
			transform: translateY(-10px);
			transition: all 0.3s ease-in-out;
			max-width: 300px;
			text-align: center;
		}

		.toast-notification.show {
			opacity: 1;
			transform: translateY(0);
		}

		.toast-notification.fade-out {
			opacity: 0;
			transform: translateY(-10px);
		}

		.timeline-container {
			margin-top: 20px;
			position: relative;
			flex: 1;
			min-height: 150px;
		}

		.timeline-axis {
			height: 30px;
			background: #f8f9fa;
			border: 1px solid #ddd;
			position: relative;
			margin-bottom: 20px;
		}

		.timeline-hour {
			position: absolute;
			top: 0;
			height: 100%;
			width: 4.1667%;
			border-right: 1px solid #ddd;
			text-align: center;
			font-size: 12px;
			padding-top: 5px;
		}

		.timeline-hour:first-child {
			border-left: none;
		}

		.timeline-hour:nth-child(2n) {
			background: rgba(0, 0, 0, 0.02);
		}

		.timeline-item {
			height: 30px;
			margin-bottom: 10px;
			position: relative;
			border-radius: 5px;
			overflow: hidden;
		}

		.timeline-block {
			position: absolute;
			height: 100%;
			background-color: #3498db;
			border-radius: 5px;
			opacity: 0.7;
			transition: opacity 0.3s;
		}

		.timeline-block:hover {
			opacity: 1;
		}

		.timeline-label {
			position: absolute;
			left: 5px;
			top: 5px;
			color: white;
			font-size: 12px;
			font-weight: bold;
			text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
		}

		.overlap-indicator {
			position: absolute;
			height: 10px;
			background-color: #e74c3c;
			border-radius: 0 0 5px 5px;
		}

		.data-list {
			margin-top: 20px;
			max-height: 200px;
			overflow-y: auto;
		}

		.data-item {
			background: #f8f9fa;
			padding: 10px;
			margin-bottom: 10px;
			border-radius: 5px;
			display: flex;
			justify-content: space-between;
			align-items: center;
		}

		.data-item-info {
			flex: 1;
		}

		.data-item-actions {
			display: flex;
			gap: 5px;
		}

		.data-item-actions button {
			width: auto;
			padding: 5px 10px;
			font-size: 12px;
		}

		.delete-btn {
			background-color: #e74c3c;
		}

		.delete-btn:hover {
			background-color: #c0392b;
		}

		.instructions {
			background-color: #f8f9fa;
			padding: 15px;
			border-radius: 5px;
			margin-top: 20px;
			font-size: 14px;
		}

		.instructions h3 {
			margin-top: 0;
			color: #2c3e50;
		}

		.timeline-title {
			margin-top: 20px;
			margin-bottom: 10px;
			font-weight: 600;
			color: #2c3e50;
		}

		@media (max-width: 768px) {
			.container {
				flex-direction: column;
			}

			.input-section, .timeline-section {
				min-width: 100%;
			}
		}
	</style>
</head>
<body>
<h1>Global Availability Timeline</h1>

<div class="container">
	<div class="input-section">
		<h2>Add Availability Period</h2>

		<div class="form-group">
			<label for="label">Label</label>
			<input type="text" id="label" placeholder="Player Name">
		</div>

		<div class="form-group">
			<label for="timezone">Timezone</label>
			<select id="timezone">
				<option value="-12">UTC-12:00</option>
				<option value="-11">UTC-11:00</option>
				<option value="-10">UTC-10:00</option>
				<option value="-9">UTC-09:00</option>
				<option value="-8">UTC-08:00</option>
				<option value="-7">UTC-07:00</option>
				<option value="-6">UTC-06:00</option>
				<option value="-5">UTC-05:00</option>
				<option value="-4">UTC-04:00</option>
				<option value="-3">UTC-03:00</option>
				<option value="-2">UTC-02:00</option>
				<option value="-1">UTC-01:00</option>
				<option value="0" selected>UTC+00:00</option>
				<option value="1">UTC+01:00</option>
				<option value="2">UTC+02:00</option>
				<option value="3">UTC+03:00</option>
				<option value="4">UTC+04:00</option>
				<option value="5">UTC+05:00</option>
				<option value="6">UTC+06:00</option>
				<option value="7">UTC+07:00</option>
				<option value="8">UTC+08:00</option>
				<option value="9">UTC+09:00</option>
				<option value="10">UTC+10:00</option>
				<option value="11">UTC+11:00</option>
				<option value="12">UTC+12:00</option>
			</select>
		</div>

		<div class="form-group">
			<label for="start-time">Start Time</label>
			<input type="time" id="start-time" value="09:00">
		</div>

		<div class="form-group">
			<label for="end-time">End Time</label>
			<input type="time" id="end-time" value="17:00">
		</div>

		<button id="add-btn">Add to Timeline</button>

		<div class="data-actions">
			<button id="share-btn" class="share-btn">Copy Share URL</button>
		</div>

		<div class="data-list" id="data-list">
			<!-- Data items will be dynamically generated here -->
		</div>

		<div class="instructions">
			<h3>Instructions</h3>
			<p>1. Add availability periods with timezone</p>
			<p>2. Click "Add to Timeline" to add periods to the timeline</p>
			<p>3. All periods are displayed in UTC+0 and selected timezone</p>
			<p>4. Red areas indicate times when ALL periods overlap</p>
			<p>5. Use "Copy Share URL" to share your timeline with others</p>
		</div>
	</div>

	<div class="timeline-section">
		<h2>Timeline</h2>

		<div class="timeline-title">UTC+0 Timezone</div>
		<div class="timeline-container">
			<div class="timeline-axis" id="utc-timeline-axis">
				<!-- UTC timeline hours will be dynamically generated here -->
			</div>
			<div id="utc-timeline-items">
				<!-- UTC timeline items will be dynamically generated here -->
			</div>
		</div>

		<div class="timeline-title" id="selected-timezone-title">Selected Timezone (UTC+0)</div>
		<div class="timeline-container">
			<div class="timeline-axis" id="selected-timeline-axis">
				<!-- Selected timezone timeline hours will be dynamically generated here -->
			</div>
			<div id="selected-timeline-items">
				<!-- Selected timezone timeline items will be dynamically generated here -->
			</div>
		</div>
	</div>
</div>

<!-- Toast Notification -->
<div class="toast-notification" id="toast-notification"></div>

<script>
	// Store all time period data
	let timeData = [];

	// DOM elements
	const timezoneSelect = document.getElementById('timezone');
	const labelInput = document.getElementById('label');
	const startTimeInput = document.getElementById('start-time');
	const endTimeInput = document.getElementById('end-time');
	const addButton = document.getElementById('add-btn');
	const shareButton = document.getElementById('share-btn');
	const toastNotification = document.getElementById('toast-notification');
	const dataList = document.getElementById('data-list');
	const utcTimelineAxis = document.getElementById('utc-timeline-axis');
	const utcTimelineItems = document.getElementById('utc-timeline-items');
	const selectedTimelineAxis = document.getElementById('selected-timeline-axis');
	const selectedTimelineItems = document.getElementById('selected-timeline-items');
	const selectedTimezoneTitle = document.getElementById('selected-timezone-title');

	// Track mouse position
	let mouseX = 0;
	let mouseY = 0;

	// Toast timer reference
	let toastTimer = null;

	// Update mouse position
	document.addEventListener('mousemove', (e) => {
		mouseX = e.clientX;
		mouseY = e.clientY;
	});

	// Show toast notification near mouse position
	function showToast(message) {
		// Clear any existing timer
		if (toastTimer) {
			clearTimeout(toastTimer);
			toastTimer = null;
		}

		// Reset toast state
		toastNotification.classList.remove('show', 'fade-out');

		// Force reflow to reset animation
		void toastNotification.offsetWidth;

		// Position toast near mouse cursor with offset
		const offsetX = 20;
		const offsetY = 20;

		toastNotification.textContent = message;
		toastNotification.style.left = (mouseX + offsetX) + 'px';
		toastNotification.style.top = (mouseY + offsetY) + 'px';

		// Show toast
		toastNotification.classList.add('show');

		// Start fade out after 1.5 seconds
		toastTimer = setTimeout(() => {
			toastNotification.classList.add('fade-out');

			// Remove toast after animation completes
			toastTimer = setTimeout(() => {
				toastNotification.classList.remove('show', 'fade-out');
				toastTimer = null;
			}, 300);
		}, 1500);
	}

	// Initialize the app
	function init() {
		// Set default timezone to user's timezone
		const userTimezone = -new Date().getTimezoneOffset() / 60;
		setTimezoneSelectValue(timezoneSelect, userTimezone);

		// Initialize timeline axes
		initTimelineAxis(utcTimelineAxis, "UTC+0");
		updateSelectedTimezoneTitle();
		initTimelineAxis(selectedTimelineAxis, getTimezoneDisplayName());

		// Check URL parameters first
		checkUrlParameters();

		// Load saved data from localStorage if no URL parameters found
		if (timeData.length === 0) {
			loadFromLocalStorage();
		}

		// Update timeline with loaded data
		updateTimeline();
	}

	// Check for URL parameters and import data if present
	function checkUrlParameters() {
		const urlParams = new URLSearchParams(window.location.search);
		const dataParam = urlParams.get('data');

		if (dataParam) {
			try {
				// Simple Base64 decoding
				const decoded = decodeURIComponent(escape(atob(dataParam)));
				const importedData = JSON.parse(decoded);

				// Validate data format and decompress
				if (Array.isArray(importedData) && importedData.every(item =>
					item.hasOwnProperty('l') &&
					item.hasOwnProperty('t') &&
					item.hasOwnProperty('s') &&
					item.hasOwnProperty('e') &&
					item.hasOwnProperty('u') &&
					item.hasOwnProperty('v')
				)) {
					// Decompress data
					timeData = importedData.map(item => ({
						id: Date.now() + Math.random(), // Generate new IDs
						label: item.l,
						timezone: item.t,
						originalStart: item.s,
						originalEnd: item.e,
						utcStart: item.u,
						utcEnd: item.v
					}));

					// Update timeline with loaded data
					updateDataList();

					// Clear URL parameters to avoid re-import on refresh
					window.history.replaceState({}, document.title, window.location.pathname);

					console.log('Data imported from URL:', timeData.length, 'periods');
				}
			} catch (error) {
				console.error('Error importing data from URL:', error);
			}
		}
	}

	// Generate and copy share URL to clipboard
	function copyShareUrl() {
		if (timeData.length === 0) {
			showToast('No data to share. Please add some availability periods first.');
			return;
		}

		// Compress data for URL
		const compressedData = timeData.map(item => ({
			l: item.label,
			t: item.timezone,
			s: item.originalStart,
			e: item.originalEnd,
			u: item.utcStart,
			v: item.utcEnd
		}));

		const dataStr = JSON.stringify(compressedData);
		// Simple Base64 encoding
		const compressed = btoa(unescape(encodeURIComponent(dataStr)));

		// Create share URL
		const baseUrl = window.location.href.split('?')[0];
		const shareUrl = `${baseUrl}?data=${encodeURIComponent(compressed)}`;

		// Copy to clipboard
		navigator.clipboard.writeText(shareUrl).then(() => {
			showToast('Share URL copied to clipboard!');
		}).catch(err => {
			// Fallback for older browsers
			const textArea = document.createElement('textarea');
			textArea.value = shareUrl;
			document.body.appendChild(textArea);
			textArea.select();
			document.execCommand('copy');
			document.body.removeChild(textArea);

			showToast('Share URL copied to clipboard!');
		});
	}

	// Get timezone display name
	function getTimezoneDisplayName() {
		const timezone = parseInt(timezoneSelect.value);
		return `UTC${timezone >= 0 ? '+' : ''}${timezone}`;
	}

	// Update selected timezone title
	function updateSelectedTimezoneTitle() {
		selectedTimezoneTitle.textContent = `Selected Timezone (${getTimezoneDisplayName()})`;
	}

	// Set the value of a timezone select element
	function setTimezoneSelectValue(selectElement, value) {
		const roundedValue = Math.max(-12, Math.min(12, Math.round(value)));
		for (let i = 0; i < selectElement.options.length; i++) {
			if (parseInt(selectElement.options[i].value) === roundedValue) {
				selectElement.selectedIndex = i;
				break;
			}
		}
	}

	// Initialize timeline axis
	function initTimelineAxis(axisElement, timezoneName) {
		axisElement.innerHTML = '';
		for (let i = 0; i < 24; i++) {
			const hourDiv = document.createElement('div');
			hourDiv.className = 'timeline-hour';
			hourDiv.style.left = `${(i / 24) * 100}%`;
			hourDiv.textContent = `${i}`;
			axisElement.appendChild(hourDiv);
		}
	}

	// Convert time to minutes
	function timeToMinutes(timeStr) {
		const [hours, minutes] = timeStr.split(':').map(Number);
		return hours * 60 + minutes;
	}

	// Convert minutes to time string
	function minutesToTime(minutes) {
		const hours = Math.floor(minutes / 60) % 24;
		const mins = minutes % 60;
		return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
	}

	// Convert local time to UTC+0 time
	function convertToUTC(localTime, timezoneOffset) {
		// Convert time to minutes
		let minutes = timeToMinutes(localTime);

		// Apply timezone offset (timezone offset in hours)
		minutes -= timezoneOffset * 60;

		// Handle day crossing
		if (minutes < 0) {
			minutes += 24 * 60;
		} else if (minutes >= 24 * 60) {
			minutes -= 24 * 60;
		}

		return minutesToTime(minutes);
	}

	// Convert UTC+0 time to local time
	function convertFromUTC(utcTime, timezoneOffset) {
		// Convert time to minutes
		let minutes = timeToMinutes(utcTime);

		// Apply timezone offset (timezone offset in hours)
		minutes += timezoneOffset * 60;

		// Handle day crossing
		if (minutes < 0) {
			minutes += 24 * 60;
		} else if (minutes >= 24 * 60) {
			minutes -= 24 * 60;
		}

		return minutesToTime(minutes);
	}

	// Add a time period
	function addTimePeriod() {
		const timezone = parseInt(timezoneSelect.value);
		const startTime = startTimeInput.value;
		const endTime = endTimeInput.value;
		const label = labelInput.value || `Period ${timeData.length + 1}`;

		if (!startTime || !endTime) {
			showToast('Please enter both start and end times');
			return;
		}

		if (!label) {
			showToast('Please enter a label');
			return;
		}

		// Convert to UTC+0 time
		const utcStart = convertToUTC(startTime, timezone);
		const utcEnd = convertToUTC(endTime, timezone);

		// Create data object
		const data = {
			id: Date.now(),
			timezone,
			originalStart: startTime,
			originalEnd: endTime,
			utcStart,
			utcEnd,
			label
		};

		// Add to data array
		timeData.push(data);

		// Update UI
		updateDataList();
		updateTimeline();
		saveToLocalStorage();

		// Clear inputs
		labelInput.value = '';
	}

	// Update data list
	function updateDataList() {
		dataList.innerHTML = '';

		timeData.forEach(data => {
			const itemDiv = document.createElement('div');
			itemDiv.className = 'data-item';

			const infoDiv = document.createElement('div');
			infoDiv.className = 'data-item-info';
			infoDiv.innerHTML = `
					<strong>${data.label}</strong><br>
					Local: ${data.originalStart} - ${data.originalEnd} (UTC${data.timezone >= 0 ? '+' : ''}${data.timezone})<br>
					UTC: ${data.utcStart} - ${data.utcEnd}
				`;

			const actionsDiv = document.createElement('div');
			actionsDiv.className = 'data-item-actions';

			const deleteBtn = document.createElement('button');
			deleteBtn.className = 'delete-btn';
			deleteBtn.textContent = 'Delete';
			deleteBtn.onclick = () => deleteTimePeriod(data.id);

			actionsDiv.appendChild(deleteBtn);
			itemDiv.appendChild(infoDiv);
			itemDiv.appendChild(actionsDiv);

			dataList.appendChild(itemDiv);
		});
	}

	// Delete a time period
	function deleteTimePeriod(id) {
		timeData = timeData.filter(data => data.id !== id);
		updateDataList();
		updateTimeline();
		saveToLocalStorage();
	}

	// Update timeline
	function updateTimeline() {
		// Update UTC timeline
		updateSingleTimeline(utcTimelineItems, true);

		// Update selected timezone timeline
		updateSelectedTimezoneTitle();
		initTimelineAxis(selectedTimelineAxis, getTimezoneDisplayName());
		updateSingleTimeline(selectedTimelineItems, false);
	}

	// Update a single timeline
	function updateSingleTimeline(timelineElement, isUTC) {
		timelineElement.innerHTML = '';

		// Calculate minute representation for all time periods
		const periods = timeData.map(data => {
			let startMinutes, endMinutes;

			if (isUTC) {
				// Use UTC times
				startMinutes = timeToMinutes(data.utcStart);
				endMinutes = timeToMinutes(data.utcEnd);
			} else {
				// Convert to selected timezone
				const selectedTimezone = parseInt(timezoneSelect.value);
				startMinutes = timeToMinutes(convertFromUTC(data.utcStart, selectedTimezone));
				endMinutes = timeToMinutes(convertFromUTC(data.utcEnd, selectedTimezone));
			}

			// Handle day crossing (end time < start time)
			let normalizedEnd = endMinutes;
			let spansMidnight = false;

			if (normalizedEnd < startMinutes) {
				normalizedEnd += 24 * 60;
				spansMidnight = true;
			}

			return {
				id: data.id,
				label: data.label,
				start: startMinutes,
				end: normalizedEnd,
				duration: normalizedEnd - startMinutes,
				spansMidnight
			};
		});

		// Draw each time period
		periods.forEach(period => {
			const itemDiv = document.createElement('div');
			itemDiv.className = 'timeline-item';

			// Handle periods that span midnight
			if (period.spansMidnight) {
				// Create first part (from start to midnight)
				const firstBlockDiv = document.createElement('div');
				firstBlockDiv.className = 'timeline-block';
				firstBlockDiv.style.left = `${(period.start / (24 * 60)) * 100}%`;
				firstBlockDiv.style.width = `${((24 * 60 - period.start) / (24 * 60)) * 100}%`;

				// Generate color based on ID
				const hue = (period.id % 12) * 30;
				firstBlockDiv.style.backgroundColor = `hsl(${hue}, 70%, 50%)`;

				const firstLabelSpan = document.createElement('span');
				firstLabelSpan.className = 'timeline-label';
				firstLabelSpan.textContent = period.label;

				firstBlockDiv.appendChild(firstLabelSpan);
				itemDiv.appendChild(firstBlockDiv);

				// Create second part (from midnight to end)
				const secondBlockDiv = document.createElement('div');
				secondBlockDiv.className = 'timeline-block';
				secondBlockDiv.style.left = '0%';
				secondBlockDiv.style.width = `${((period.end - 24 * 60) / (24 * 60)) * 100}%`;
				secondBlockDiv.style.backgroundColor = `hsl(${hue}, 70%, 50%)`;

				itemDiv.appendChild(secondBlockDiv);
			} else {
				// Normal period (doesn't span midnight)
				const blockDiv = document.createElement('div');
				blockDiv.className = 'timeline-block';
				blockDiv.style.left = `${(period.start / (24 * 60)) * 100}%`;
				blockDiv.style.width = `${(period.duration / (24 * 60)) * 100}%`;

				// Generate color based on ID
				const hue = (period.id % 12) * 30;
				blockDiv.style.backgroundColor = `hsl(${hue}, 70%, 50%)`;

				const labelSpan = document.createElement('span');
				labelSpan.className = 'timeline-label';
				labelSpan.textContent = period.label;

				blockDiv.appendChild(labelSpan);
				itemDiv.appendChild(blockDiv);
			}

			timelineElement.appendChild(itemDiv);
		});

		// Calculate and display overlap areas (only where ALL periods overlap)
		showOverlaps(timelineElement, periods);
	}

	// Show overlapping time periods (only where ALL periods overlap)
	function showOverlaps(timelineElement, periods) {
		if (periods.length === 0) return;

		// Create an array representing each minute of the day
		const dayMinutes = new Array(24 * 60).fill(0);

		// Mark each minute covered by time periods
		periods.forEach(period => {
			for (let i = period.start; i < period.end; i++) {
				const minuteIndex = i % (24 * 60);
				dayMinutes[minuteIndex]++;
			}
		});

		// Find overlapping areas (minutes covered by ALL periods)
		const totalPeriods = periods.length;
		let overlapStart = null;
		for (let i = 0; i < dayMinutes.length; i++) {
			if (dayMinutes[i] === totalPeriods) {
				if (overlapStart === null) {
					overlapStart = i;
				}
			} else {
				if (overlapStart !== null) {
					// Create overlap indicator
					const overlapDiv = document.createElement('div');
					overlapDiv.className = 'overlap-indicator';
					overlapDiv.style.left = `${(overlapStart / (24 * 60)) * 100}%`;
					overlapDiv.style.width = `${((i - overlapStart) / (24 * 60)) * 100}%`;

					timelineElement.appendChild(overlapDiv);
					overlapStart = null;
				}
			}
		}

		// Handle overlaps spanning midnight
		if (overlapStart !== null) {
			const overlapDiv = document.createElement('div');
			overlapDiv.className = 'overlap-indicator';
			overlapDiv.style.left = `${(overlapStart / (24 * 60)) * 100}%`;
			overlapDiv.style.width = `${((24 * 60 - overlapStart) / (24 * 60)) * 100}%`;

			timelineElement.appendChild(overlapDiv);
		}
	}

	// Save to localStorage
	function saveToLocalStorage() {
		localStorage.setItem('timelineData', JSON.stringify(timeData));
	}

	// Load from localStorage
	function loadFromLocalStorage() {
		const savedData = localStorage.getItem('timelineData');
		if (savedData) {
			try {
				timeData = JSON.parse(savedData);
				updateDataList();
			} catch (error) {
				console.error('Error loading saved data:', error);
			}
		}
	}

	// Event listeners
	addButton.addEventListener('click', addTimePeriod);
	shareButton.addEventListener('click', copyShareUrl);

	// Update timeline when timezone changes
	timezoneSelect.addEventListener('change', updateTimeline);

	// Initialize the app
	init();
</script>
</body>
</html>